# 设计模式学习（C++）

本项目基于极客时间王争老师的《设计模式之美》课程，使用 C++ 实现了多种设计模式的示例（示例思路主要来源于上述课程以及 ChatGPT ）。本项目也包含一些本人对设计模式的见解，以供大家交流和学习。



## 工程目录结构

```bash
Project:.
├─bin               // 可执行文件及相关依赖
├─CMakeLists.txt
├─include           // 头文件，.h / .hpp
  ├─Behavioral        // 行为型模式
  ├─Creational        // 创建型模式
  ├─Structural        // 结构型模式
├─main.cpp
└─src               // 源文件，.c / .cpp

// 开发环境：CLion + MinGW
```



## 设计模式介绍

### 1. 创建型模式    include/Creational/

- **单例模式	singleton.hpp**

   用于创建全局唯一的对象。主要包括饿汉式、懒汉式和枚举三种实现方式。

- **工厂方法模式	factory.hpp**

   用于创建相关类型的不同对象，这些对象继承自同一父类或者接口的一组子类，由给定的参数来决定创建哪种类型的对象。

- **抽象工厂模式	factory.hpp**

   用于创建双分类的工厂和产品对象。

- **建造者模式	builder.hpp**

   用于按照预设步骤来创建复杂的对象，可以通过在预设步骤中设置不同的可选参数，“定制化” 地创建出不同的对象。

- 原型模式	prototype.hpp

   用于通过拷贝（深拷贝 / 浅拷贝）的方式创建对象。

### 2. 结构型模式    include/Structural/

- **代理模式	proxy.hpp**

   在不改变原始类接口的条件下，为原始类定义一个代理类，相当于套了一层壳，主要目的是控制访问，而不是加强功能。一般情况下，在开发代理类时，会让代理类和原始类实现同样的接口，但如果原始类没有接口，则可以让代理类继承原始类来实现代理模式。该工程代码目前只实现了静态代理模式，没有实现动态代理模式。

- **桥接模式	bridge.hpp**

   将 “抽象”（指一套被抽象出来的类库）和 “实现”（指另一套独立的类库）解耦，让它们能独立开发，再通过对象之间的组合关系将它们组装在一起。

- **装饰器模式	decorator.hpp**

   为原始类定义一个装饰器类，相当于套了一层壳，主要解决继承关系过于复杂的问题，通过组合来代替继承，给原始类添加增强功能。装饰器类和原始类需要实现同样的接口。可以对原始类嵌套使用多个装饰器。

- **适配器模式	adapter.hpp**

   适配器提供跟原始类不同的接口，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有 “类适配器”（使用继承关系）和 “对象适配器”（使用组合关系）两种实现方式。

- 门面模式	facade.hpp

   根据业务的需要，通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或用于解决性能、分布式事务等问题。

- 组合模式	composite.hpp

   主要用于处理树形结构数据，可将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以便于统一处理逻辑。抽象地说，数据可以表示为树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。

- 享元模式	flyweight.hpp

   目的是复用对象、节省内存，前提是享元对象是不可变对象。可用 “简单工厂 + 单例模式” 的方法来提前创建好享元对象缓存，即在内存中只保留一份实例，可供多处代码引用。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。

### 3. 行为型模式    include/Behavioral/

- **观察者模式	observer.hpp**

   将 观察者（订阅者）和 被观察者（发布者）解耦。

- **模板模式	template.hpp**

   在一个方法中定义一个算法骨架，将其中的某些步骤抽象成接口，推迟到子类中实现。即让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。主要目的是复用和扩展，其中，复用是指，所有的子类可以复用父类中提供的模板方法的代码；扩展是指，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。

- **策略模式	strategy.hpp**

   定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式使算法的变化独立于使用它们的客户端（代指使用算法的代码），也使客户端避免冗长的 if-else 或 switch 分支判断。策略的创建可以用工厂模式来实现。

- **职责链模式	responsibility.hpp**

   将多个处理器串成一个链条，依次处理同一个请求，链条上的每个处理器各自承担着各自的处理职责。在职责链上，可以是使请求经适合的处理器处理后终止传递，也可以是使请求被所有的处理器都处理一遍。

- **状态模式	state.hpp**

   一般用来实现状态机（又称有限状态机），由状态、事件和动作三部分组成，其中，事件也称为转移事件，其作用是触发状态的转移以及动作的执行。

- **迭代器模式	iterator.hpp**

   也称游标模式，用来遍历集合对象。

- 访问者模式	visitor.hpp

   允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身。

- 备忘录模式	memento.hpp

   也称快照模式，其作用是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后能够恢复对象为之前的状态。根据实际情况，可以选择备份对象的全部信息或部分必要信息。

- 命令模式	command.hpp

   将命令函数封装成对象，再使用一个命令操作对象来控制命令的执行。

- 解释器模式	interpreter.hpp

    为某个 “语言” 定义它的 “语法表示“，并定义一个解释器用来处理这个语法。

- 中介模式	mediator.hpp

    通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多转换为一对多，实现参与者之间的解耦。即这组对象将它们之间的交互委托给中介对象，以避免它们之间的直接交互。


# 设计模式学习代码（C++）



## 1. 工程目录结构

```bash
Project:.
├─bin               // 可执行文件及相关依赖
├─CMakeLists.txt
├─include           // 头文件，.h / .hpp
  ├─Behavior          // 行为型模式
  ├─Creational        // 创建型模式
  ├─Structural        // 结构型模式
├─main.cpp
└─src               // 源文件，.c / .cpp

// 本人环境：CLion + MinGW
```



## 2. 设计模式介绍

### 2.1 创建型模式    include/Creational/

1. **单例模式	singleton.hpp**

   用于创建全局唯一的对象。主要包括饿汉式、懒汉式和枚举三种实现方式。

2. **工厂方法模式	factory.hpp**

   用于创建相关类型的不同对象，这些对象继承自同一父类或者接口的一组子类，由给定的参数来决定创建哪种类型的对象。

3. **抽象工厂模式	factory.hpp**

   用于创建双分类的工厂和产品对象。

4. **建造者模式	builder.hpp**

   用于按照预设步骤来创建复杂的对象，可以通过在预设步骤中设置不同的可选参数，“定制化” 地创建出不同的对象。

5. 原型模式	prototype.hpp

   用于通过拷贝（深拷贝 / 浅拷贝）的方式创建对象。

### 2.2 结构型模式    include/Structural/

1. **代理模式	proxy.hpp**

   在不改变原始类接口的条件下，为原始类定义一个代理类，相当于套了一层壳，主要目的是控制访问，而不是加强功能。一般情况下，在开发代理类时，会让代理类和原始类实现同样的接口，但如果原始类没有接口，则可以让代理类继承原始类来实现代理模式。该工程代码目前只实现了静态代理模式，没有实现动态代理模式。

2. **桥接模式	bridge.hpp**

   将 “抽象”（指一套被抽象出来的类库）和 “实现”（指另一套独立的类库）解耦，让它们能独立开发，再通过对象之间的组合关系将它们组装在一起。

3. **装饰器模式	decorator.hpp**

   为原始类定义一个装饰器类，相当于套了一层壳，主要解决继承关系过于复杂的问题，通过组合来代替继承，给原始类添加增强功能。装饰器类和原始类需要实现同样的接口。可以对原始类嵌套使用多个装饰器。

4. **适配器模式	adapter.hpp**

   适配器提供跟原始类不同的接口，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有 “类适配器”（使用继承关系）和 “对象适配器”（使用组合关系）两种实现方式。

5. 门面模式	facade.hpp

   根据业务的需要，通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或用于解决性能、分布式事务等问题。

6. 组合模式	composite.hpp

   主要用于处理树形结构数据，可将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以便于统一处理逻辑。抽象地说，数据可以表示为树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。

7. 享元模式	flyweight.hpp

   目的是复用对象、节省内存，前提是享元对象是不可变对象。可用 “简单工厂 + 单例模式” 的方法来提前创建好享元对象缓存，即在内存中只保留一份实例，可供多处代码引用。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。

### 2.3 行为型模式    include/Behavior/

1. **观察者模式	observer.hpp**
2. **模板模式	template.hpp**
3. **策略模式	strategy.hpp**
4. **职责链模式	responsibility.hpp**
5. **状态模式	state.hpp**
6. **迭代器模式	iterator.hpp**
7. 访问者模式	visitor.hpp
8. 备忘录模式	memento.hpp
9. 命令模式	command.hpp
10. 解释器模式	interpreter.hpp
11. 中介模式	mediator.hpp

